<!DOCTYPE html>
<html lang="es">

<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="Author" content="Equipo 2" />
    <!--Autor-->

    <meta name="Description" content="Estudio General del Sistema" />
    <!--Descripción del tutorial-->
    <meta name="Keywords" content="Factores, Estudio, General, Sistema" />
    <!--Palabras clave-->
    <meta name="robots" content="noindex, nofollow" />

    <script src="media/js/jq.js" type="text/javascript"></script>
    <script src="media/js/m.js" type="text/javascript"></script>
    <script src="media/js/ui.js" type="text/javascript"></script>

    <link rel="stylesheet" href="media/css/ui.css" type="text/css" />

    <!-- Integración de MathJax para renderizar LaTeX -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- El siguiente CSS puede utilizarse para hacer los ajustes necesarios de los contenidos -->
    <link rel="stylesheet" href="media/css/ejemplos.css" type="text/css" />
    <style>
        div#hiddenText010 {
            line-height: 35px;
        }
    </style>
</head>
<section class="main clearfix">
    <section class="top">
        <img src="img\ejemBK.jpg" class="media" alt="" />
        <div class="wrapper content_header clearfix">
            <center>
                <h1 class="title"><br>4. Ejemplos </h1>
            </center>
        </div>
    </section>

    <section class="wrapper">
        <div class="content">
            <ul>
                <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
                <h2>
                    <v>4.1 Propiedades Avanzadas de Grafos </v>
                </h2>
                <li>
                    <h3>4.1.1 Ejemplo 1: Cálculo de Girth y Diámetro en una Red Social

                    </h3>
                </li>
                <h4 style="text-align: justify;">
                    Una red social se representa mediante un grafo no dirigido, donde cada nodo es un usuario y cada
                    arista es una conexión de amistad. Calcular: <br><br>
                    &emsp;&emsp;a) El girth del grafo (longitud del ciclo más corto). <br>
                    &emsp;&emsp;b) El diámetro del grafo (distancia máxima entre dos nodos).


                    <a href="#"
                        onclick="document.getElementById('hiddenText010').style.display='block'; return false;">SOLUCIÓN.</a>
                    <div style="display: none;" id="hiddenText010">
                        <br><br>
                        <o>Paso 1:</o> Para resolver el problema de calcular el <b>girth</b> y el <b>diámetro</b> de un
                        grafo que representa una red social, recordemos los conceptos básicos:<br>
                        <br><b>Girth:</b> La longitud del ciclo más corto en el grafo. Si no hay ciclos, el <b>girth</b>
                        es infinito.<br>
                        <b>Diámetro:</b> La distancia máxima entre dos nodos en el grafo, medida en el número de aristas
                        en la ruta más corta.<br>

                        <br><br> <a href="#"
                            onclick="document.getElementById('hiddenText011').style.display='block'; return false;">SIGUIENTE</a>

                        <div style="display: none;" id="hiddenText011">
                            <br><br>
                            <o>Paso 2:</o> Supongamos que tenemos un grafo \( G = (V, E) \), donde \( V \) es el
                            conjunto de nodos (usuarios) y \( E \) es el conjunto de aristas (amistades).<br><br>
                            &emsp;&emsp;a) Para calcular el <b>girth</b>, usamos un algoritmo de búsqueda en anchura
                            (BFS) o de profundidad (DFS). Al explorar, detectamos ciclos y medimos su longitud.<br>
                            &emsp;&emsp;b) Para calcular el <b>diámetro</b>, aplicamos el algoritmo de Floyd-Warshall o
                            múltiples BFS desde cada nodo para encontrar las distancias mínimas entre todos los pares de
                            nodos.<br>

                            <br><br> <a href="#"
                                onclick="document.getElementById('hiddenText012').style.display='block'; return false;">SIGUIENTE</a>

                            <div style="display: none;" id="hiddenText012">
                                <br><br>
                                <o>Paso 3:</o> A continuación, detallamos el proceso en forma de pseudocódigo para ambos
                                cálculos:<br><br>
                                <b>Para calcular el Girth:</b>
                                <pre>
girth = ∞
Para cada nodo u en V:
    Realiza una BFS desde u
    Para cada nodo v alcanzado desde u:
        Si v ya fue visitado y no es el padre de u en el camino:
            Calcula la longitud del ciclo
            Si esta longitud < girth:
                girth = longitud del ciclo
            </pre>

                                <b>Para calcular el Diámetro:</b>
                                <pre>
diámetro = 0
Para cada nodo u en V:
    Realiza una BFS desde u para calcular las distancias a todos los otros nodos
    máxima_distancia = distancia máxima encontrada desde u
    Si máxima_distancia > diámetro:
        diámetro = máxima_distancia
            </pre>

                            </div>
                            <a href="#"
                                onclick="document.getElementById('hiddenText013').style.display='block'; return false;">SIGUIENTE</a>

                            <div style="display: none;" id="hiddenText013">
                                <br><br>
                                <o>Paso 4:</o> Vamos a calcular el <b>girth</b> y el <b>diámetro</b> utilizando un
                                ejemplo específico. Supongamos que tenemos el siguiente grafo:


                                <b>Descripción del grafo:</b>
                                - Nodos (usuarios): A, B, C, D, E
                                - Aristas (amistades): (A, B), (A, C), (B, C), (C, D), (D, E), (C, E)

                                <br><br><b>1. Cálculo del Girth:</b><br>
                                - Utilizando el algoritmo de BFS desde cada nodo, encontramos los ciclos:
                                - Desde A: (A, B, C, A) -> Longitud 3
                                - Desde B: (B, C, A, B) -> Longitud 3
                                - Desde C: (C, D, E, C) -> Longitud 3
                                - El ciclo más corto es de longitud 3.

                                Por lo tanto, el <b>girth</b> del grafo es:
                                <br><b>Girth = 3</b>

                                <br><br>2. Cálculo del Diámetro:<br>
                                - Usamos BFS desde cada nodo para encontrar las distancias máximas:
                                - Desde A: Distancias [A-B:1, A-C:1, A-D:2, A-E:2] -> Máxima 2
                                - Desde B: Distancias [B-A:1, B-C:1, B-D:2, B-E:3] -> Máxima 3
                                - Desde C: Distancias [C-A:1, C-B:1, C-D:1, C-E:1] -> Máxima 1
                                - Desde D: Distancias [D-A:2, D-B:2, D-C:1, D-E:1] -> Máxima 2
                                - Desde E: Distancias [E-A:2, E-B:3, E-C:1, E-D:1] -> Máxima 3

                                La distancia máxima encontrada es 3 (desde B a E o E a B).

                                Por lo tanto, el <b>diámetro</b> del grafo es:
                                <br><b>Diámetro = 3</b>

                                <p><br><b>Resultados finales:</b></p>
                                <p><b>Girth:</b> 3<br><b>Diámetro:</b> 3</p>
                            </div>

                        </div>
                    </div>
        </diV>


        <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
        <li>
            <h3>4.1.2 Ejemplo 2: Búsqueda en Profundidad (DFS) en un Laberinto</h3>
        </li>
        <h4 style="text-align: justify;">
            Se tiene un laberinto representado como un grafo, donde cada nodo es una intersección y cada arista un
            pasillo. Usando DFS, encontrar: <br><br>
            &emsp; a) La ruta que lleva desde la entrada hasta la salida.<br>
            &emsp; b) La detección de ciclos dentro del laberinto.
            <br><br>

            <a href="#"
                onclick="document.getElementById('hiddenText020').style.display='block'; return false;">SOLUCIÓN.</a>
            <div style="display: none;" id="hiddenText020">
                <br><br>
                <o>Paso 1:</o> En este ejercicio, utilizaremos el algoritmo de búsqueda en profundidad (DFS) para
                explorar un laberinto que se representa como un grafo. Cada nodo representa una intersección, y cada
                arista representa un pasillo. Nuestro objetivo es encontrar:<br>
                &emsp;&emsp;a) La ruta desde la entrada hasta la salida.<br>
                &emsp;&emsp;b) La detección de ciclos dentro del laberinto.<br>

                <br><br> <a href="#"
                    onclick="document.getElementById('hiddenText021').style.display='block'; return false;">SIGUIENTE</a>

                <div style="display: none;" id="hiddenText021">
                    <br><br>
                    <o>Paso 2:</o> Supongamos que el laberinto está representado por el siguiente grafo:


                    <b>Descripción del grafo:</b>
                    - Nodos (intersecciones): A (entrada), B, C, D, E (salida)
                    - Aristas (pasillos): (A, B), (A, C), (B, D), (C, E), (D, E)

                    <br><br> Usaremos DFS para encontrar la ruta desde la entrada (A) hasta la salida (E).

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText022').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText022">
                        <br><br>
                        <o>Paso 3:</o> Implementaremos DFS para buscar la ruta y detectar ciclos. El pseudocódigo es el
                        siguiente:<br><br>

                        <b>Para encontrar la ruta usando DFS:</b>
                        <pre>
    ruta = []
    function DFS(nodo, destino, visitado):
        visitado.add(nodo)
        ruta.append(nodo)
        Si nodo == destino:
            retornar ruta
        Para cada vecino en grafo[nodo]:
            Si vecino no está en visitado:
                resultado = DFS(vecino, destino, visitado)
                Si resultado no es vacío:
                    retornar resultado
        ruta.pop()
        retornar []
    
    # Inicializamos la búsqueda
    ruta_encontrada = DFS('A', 'E', set())
                                    </pre>

                        <p><br><b>Resultado a)</b> La ruta encontrada desde la entrada hasta la salida es:</p>
                        <p><b>Ruta:</b> A -> B -> D -> E</p>

                        <br><br><b>Para detectar ciclos:</b>
                        <pre>
    ciclos = []
    function DFS_ciclos(nodo, visitado, pila):
        visitado.add(nodo)
        pila.add(nodo)
        Para cada vecino en grafo[nodo]:
            Si vecino está en pila:
                ciclos.append((nodo, vecino))  # Se detecta un ciclo
            Si vecino no está en visitado:
                DFS_ciclos(vecino, visitado, pila)
        pila.remove(nodo)
                        
    # Inicializamos la detección de ciclos
    DFS_ciclos('A', set(), set())
                                    </pre>

                        <p><br><b>Resultado b)</b> Se detectan los siguientes ciclos (si los hay):</p>
                        <p><b>Ciclos encontrados:</b> (B, D) - Ejemplo de ciclo, dependiendo de las conexiones.</p>
                    </div>
                </div>
            </div>

        </h4>
        </div>
        </div>
        </div>

        <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
        <li>
            <h3>4.1.3 Ejemplo 3: Búsqueda en Anchura (BFS) en Redes de Transporte</h3>
        </li>
        <h4 style="text-align: justify;">
            En una red de transporte urbano, cada nodo representa una estación y cada arista una ruta directa. Usando
            BFS, calcular:    <br><br>
            &emsp; a) La ruta más corta entre dos estaciones específicas.<br>
            &emsp; b) Las estaciones alcanzables desde una estación de origen en N pasos.
            <br><br>

            <a href="#"
                onclick="document.getElementById('hiddenText030').style.display='block'; return false;">SOLUCIÓN.</a>
            <div style="display: none;" id="hiddenText030">
                <br><br>
                <o>Paso 1:</o> En este ejercicio, utilizaremos el algoritmo de búsqueda en anchura (BFS) para explorar
                una red de transporte urbano. Cada nodo representa una estación, y cada arista representa una ruta
                directa entre estaciones. Nuestro objetivo es calcular:<br>
                &emsp;&emsp;a) La ruta más corta entre dos estaciones específicas.<br>
                &emsp;&emsp;b) Las estaciones alcanzables desde una estación de origen en \( N \) pasos.<br>

                <br><br> <a href="#"
                    onclick="document.getElementById('hiddenText031').style.display='block'; return false;">SIGUIENTE</a>

                <div style="display: none;" id="hiddenText031">
                    <br><br>
                    <o>Paso 2:</o> Supongamos que la red de transporte está representada por el siguiente grafo:

                    <br><img src="media/img/red_transporte.png" alt="Grafo de la red de transporte"
                        style="width:300px;height:auto;">

                    <b>Descripción del grafo:</b>
                    - Nodos (estaciones): A (origen), B, C, D, E (destino)
                    - Aristas (rutas): (A, B), (A, C), (B, D), (C, E), (D, E)

                    <br><br> Usaremos BFS para encontrar la ruta más corta entre las estaciones A y E.

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText032').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText032">
                        <br><br>
                        <o>Paso 3:</o> Implementaremos BFS para buscar la ruta más corta y determinar las estaciones
                        alcanzables en \( N \) pasos. El pseudocódigo es el siguiente:<br><br>

                        <b>Para encontrar la ruta más corta usando BFS:</b>
                        <pre>
function BFS(origen, destino):
    cola = [origen]
    visitados = {origen}
    predecesores = {}

    Mientras cola no esté vacía:
        nodo_actual = cola.pop(0)
        Si nodo_actual == destino:
            ruta = []
            mientras nodo_actual está en predecesores:
                ruta.insert(0, nodo_actual)
                nodo_actual = predecesores[nodo_actual]
            retornar ruta
        Para cada vecino en grafo[nodo_actual]:
            Si vecino no está en visitados:
                visitados.add(vecino)
                predecesores[vecino] = nodo_actual
                cola.append(vecino)
    retornar []

# Inicializamos la búsqueda
ruta_mas_corta = BFS('A', 'E')
            </pre>

                        <p><br><b>Resultado a)</b> La ruta más corta encontrada desde la estación A hasta la estación E
                            es:</p>
                        <p><b>Ruta:</b> A -> B -> D -> E</p>

                        <br><br><b>Para encontrar estaciones alcanzables en N pasos:</b>
                        <pre>
function estaciones_alcanzables(origen, N):
    cola = [(origen, 0)]  # (nodo, pasos)
    visitados = {origen}
    alcanzables = []

    Mientras cola no esté vacía:
        nodo_actual, pasos = cola.pop(0)
        Si pasos == N:
            alcanzables.append(nodo_actual)
        Si pasos < N:
            Para cada vecino en grafo[nodo_actual]:
                Si vecino no está en visitados:
                    visitados.add(vecino)
                    cola.append((vecino, pasos + 1))
    retornar alcanzables

# Inicializamos la búsqueda con N pasos
alcanzables = estaciones_alcanzables('A', 2)
            </pre>

                        <p><br><b>Resultado b)</b> Las estaciones alcanzables desde la estación A en 2 pasos son:</p>
                        <p><b>Estaciones alcanzables:</b> B, C</p>
                    </div>
                </div>
            </div>
        </h4>

        <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
        <h2>
            <v>4.2 Árboles y Algoritmos de Optimización </v>
        </h2>
        <li>
            <h3>4.2.1 Ejemplo 4: Árbol de Expansión Mínima para una Red de Internet
            </h3>
        </li>
        <h4 style="text-align: justify;">
            Dada una red de ciudades interconectadas, cada ciudad es un nodo y cada conexión un cable de costo conocido.
            Usar un algoritmo de árbol de expansión mínima para:    <br><br>
            &emsp; a) Determinar el costo mínimo de interconectar todas las ciudades. <br>
            &emsp; b) dentificar las conexiones críticas que deben mantenerse.

            <a href="#"
                onclick="document.getElementById('hiddenText040').style.display='block'; return false;">SOLUCIÓN.</a>
            <div style="display: none;" id="hiddenText040">
                <br><br>
                <o>Paso 1:</o> En este ejercicio, utilizaremos un algoritmo de árbol de expansión mínima para analizar
                una red de ciudades interconectadas. Cada ciudad es un nodo y cada conexión es un cable con un costo
                conocido. Nuestro objetivo es realizar las siguientes tareas:<br>
                &emsp;&emsp;a) Determinar el costo mínimo de interconectar todas las ciudades.<br>
                &emsp;&emsp;b) Identificar las conexiones críticas que deben mantenerse.<br>

                <br><br> <a href="#"
                    onclick="document.getElementById('hiddenText041').style.display='block'; return false;">SIGUIENTE</a>

                <div style="display: none;" id="hiddenText041">
                    <br><br>
                    <o>Paso 2:</o> Supongamos que la red de ciudades está representada por el siguiente grafo:


                    <b>Descripción del grafo:</b>
                    - Nodos (ciudades): A, B, C, D, E<br>
                    - Aristas (conexiones y costos): <br>
                    - (A, B): 4<br>
                    - (A, C): 2<br>
                    - (B, C): 5<br>
                    - (B, D): 10<br>
                    - (C, D): 3<br>
                    - (C, E): 8<br>
                    - (D, E): 6<br>

                    <br><br> Usaremos el algoritmo de Kruskal o Prim para determinar el árbol de expansión mínima.

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText042').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText042">
                        <br><br>
                        <o>Paso 3:</o> Implementaremos el algoritmo de Kruskal para encontrar el costo mínimo de
                        interconectar todas las ciudades. El pseudocódigo es el siguiente:<br><br>

                        <b>Para calcular el costo mínimo usando el algoritmo de Kruskal:</b>
                        <pre>
    function Kruskal(ciudades, conexiones):
        costo_total = 0
        arbol = []
        ordenar(conexiones por costo)  # Ordenar conexiones de menor a mayor
    
        crear_conjuntos(ciudades)  # Crear un conjunto para cada ciudad
    
        Para cada conexion en conexiones:
            Si las ciudades en la conexión están en diferentes conjuntos:
                agregar conexion a arbol
                unir conjuntos
                costo_total += costo de la conexión
    
        retornar costo_total, arbol
    
    # Inicializamos el cálculo
    costo_minimo, conexiones_minimas = Kruskal([A, B, C, D, E], [(A, B, 4), (A, C, 2), (B, C, 5),<br> (B, D, 10), (C, D, 3), (C, E, 8), (D, E, 6)])
                                    </pre>

                        <p><br><b>Resultado a)</b> El costo mínimo de interconectar todas las ciudades es:</p>
                        <p><b>Costo mínimo:</b> 15</p>

                        <p>Las conexiones seleccionadas para el árbol de expansión mínima son:</p>
                        <p><b>Conexiones:</b> (A, C), (C, D), (D, E), (A, B)</p>

                        <br><br><b>Para identificar conexiones críticas:</b>
                        <pre>
    function conexiones_criticas(conexiones_minimas):
        criticas = []
        Para cada conexion en conexiones_minimas:
            eliminar conexion del grafo original
            costo_sin_conexion = Kruskal(ciudades, conexiones)  # Recalcular el costo mínimo sin la conexión
            Si costo_sin_conexion > costo_minimo:
                criticas.append(conexion)  # Si el costo aumenta, es crítica
            restaurar conexion al grafo original
        retornar criticas
    
    # Inicializamos la búsqueda de conexiones críticas
    criticas = conexiones_criticas(conexiones_minimas)
                                    </pre>

                        <p><br><b>Resultado b)</b> Las conexiones críticas que deben mantenerse son:</p>
                        <p><b>Conexiones críticas:</b> (A, C), (C, D)</p>
                    </div>
                </div>
            </div>
        </h4>
        <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
        <h2>
            <v>4.3 Conectividad en Grafos </v>
        </h2>
        <li>
            <h3>4.3.1 Ejemplo 6: Grado de Vértices en una Red de Amigos
            </h3>
        </li>
        <h4 style="text-align: justify;">
            En una red social donde cada nodo es una persona y cada arista es una amistad, calcular:  <br><br>
            &emsp; a) El grado de cada nodo. <br>
            &emsp; b) La persona con mayor número de conexiones. <br>

            <a href="#"
                onclick="document.getElementById('hiddenText060').style.display='block'; return false;">SOLUCIÓN.</a>
            <div style="display: none;" id="hiddenText060">
                <br><br>
                <o>Paso 1:</o> En este ejercicio, analizaremos una red social representada como un grafo, donde cada
                nodo representa a una persona y cada arista representa una amistad. Vamos a calcular lo siguiente:<br>
                &emsp;&emsp;a) El grado de cada nodo.<br>
                &emsp;&emsp;b) La persona con mayor número de conexiones.<br>

                <br><br> <a href="#"
                    onclick="document.getElementById('hiddenText061').style.display='block'; return false;">SIGUIENTE</a>

                <div style="display: none;" id="hiddenText061">
                    <br><br>
                    <o>Paso 2:</o> Supongamos que la red de amigos está representada por el siguiente grafo:

                    

                    <b>Descripción del grafo:</b>
                    - Nodos (personas): A, B, C, D, E, F<br>
                    - Aristas (amistades):<br>
                    - (A, B)<br>
                    - (A, C)<br>
                    - (B, C)<br>
                    - (B, D)<br>
                    - (C, E)<br>
                    - (D, E)<br>
                    - (E, F)<br>

                    <br><br> Vamos a calcular el grado de cada nodo y encontrar la persona con más conexiones.

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText062').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText062">
                        <br><br>
                        <o>Paso 3:</o> Para calcular el grado de cada nodo, contamos el número de aristas conectadas a
                        cada uno. Esto se puede expresar como:

                        \[
                        \text{Grado}(v) = \text{Número de aristas conectadas al nodo } v
                        \]

                        <b>Grado de cada nodo:</b>
                        <ul>
                            <li>Grado(A) = 2 (A está conectado a B y C)</li>
                            <li>Grado(B) = 3 (B está conectado a A, C y D)</li>
                            <li>Grado(C) = 3 (C está conectado a A, B y E)</li>
                            <li>Grado(D) = 2 (D está conectado a B y E)</li>
                            <li>Grado(E) = 3 (E está conectado a C, D y F)</li>
                            <li>Grado(F) = 1 (F está conectado a E)</li>
                        </ul>

                        <p><br><b>Resultado a)</b> El grado de cada nodo es el siguiente:</p>
                        <p><b>Grados:</b></p>
                        <ul>
                            <li>A: 2</li>
                            <li>B: 3</li>
                            <li>C: 3</li>
                            <li>D: 2</li>
                            <li>E: 3</li>
                            <li>F: 1</li>
                        </ul>

                        <br><br>
                        <o>Paso 4:</o> Ahora, vamos a identificar a la persona con el mayor número de conexiones.
                        Observando los grados calculados:

                        <b>Persona con mayor número de conexiones:</b>
                        - Personas B, C y E tienen un grado de 3, que es el mayor entre todos.

                        <p><br><b>Resultado b)</b> Las personas con el mayor número de conexiones son:</p>
                        <p><b>Personas:</b> B, C, E</p>
                    </div>
                </div>
            </div>

        </h4>


            <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
            <li>
                <h3>4.3.2 Ejemplo 7: Subgrafos Conexos en una Red de Telecomunicaciones
                </h3>
            </li>
            <h4 style="text-align: justify;">
                Dada una red de telecomunicaciones, dividirla en subgrafos conexos: <br>
                &emsp;&emsp;a) Identificar regiones conectadas. <br>
                &emsp;&emsp;b) Analizar la interconexión entre estos subgrafos. <br>

                <br><a href="#"
                    onclick="document.getElementById('hiddenText060').style.display='block'; return false;">SOLUCIÓN.</a>
                <div style="display: none;" id="hiddenText060">

                    <br><br>
                    <o>Paso 1:</o> Vamos a definir los siguientes eventos:<br>
                    <br><img src="media/img/paso1_ej6.png" alt="">

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText061').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText061">

                        <br><br>
                        <o>Paso 2:</o> Analizando el problema…<br><br>
                        Hay un total de 36 resultados posibles al lanzar dos dados, ya que hay 6 posibilidades para el
                        primer dado y 6
                        posibilidades para el segundo dado, lo que resulta en 6&#215;6=36 resultados posibles en total.
                        <br><br>
                        * Para el evento A: "el primer dado muestra un número par", hay 18 resultados favorables, ya que
                        hay 3 números
                        pares (2, 4 y 6) en un dado de 6 caras, y 3 posibilidades para el segundo dado. <br>
                        * Para el evento B: "el segundo dado muestra un 5 o un 6", hay 12 resultados favorables, ya que
                        hay 2 posibilidades
                        (5 y 6) en un dado de 6 caras, y 6 posibilidades para el primer dado. <br><br>
                        La siguiente tabla muestra las combinaciones posibles:
                        <img src="media/img/paso2_ej3.png" alt="">

                        <br><br> <a href="#"
                            onclick="document.getElementById('hiddenText062').style.display='block'; return false;">SIGUIENTE</a>

                        <div style="display: none;" id="hiddenText062">

                            <br><br>
                            <o>Paso 3:</o> Usando la fórmula de probabilidad. <br>
                            <br><img src="media/img/paso3_ej6.png" alt="">

                            <br><br> <a href="#"
                                onclick="document.getElementById('hiddenText063').style.display='block'; return false;">SIGUIENTE</a>

                            <div style="display: none;" id="hiddenText063">
                                <br><br>
                                <o>Paso 4:</o> Usaremos la fórmula de intersección de dos eventos.<br><br>
                                <img src="media/img/paso4_ej6.png" alt="">

                                <br><br> <a href="#"
                                    onclick="document.getElementById('hiddenText064').style.display='block'; return false;">SIGUIENTE</a>

                                <div style="display: none;" id="hiddenText064">
                                    <br><br>
                                    <o>Paso 5:</o> Usaremos la fórmula de probabilidad condicional.<br>
                                    <br><img src="media/img/paso5_ej6.png" height="250" width="100" alt=""><br>
                                    Así encontramos, como era de suponer, que la probabilidad no condicional es igual a
                                    la probabilidad condicional P(A/B).
                                    De modo semejante: <br><br>
                                    <img src="media/img/paso5_ej62.png" alt=""><br>
                                    Por lo tanto, podríamos inclinarnos a decir que A y B son independientes si y sólo
                                    si P(B|A)=P(A) y P(A|B)=P(B). Aunque
                                    esto sería esencialmente apropiado, hay otro método que evita la dificultad
                                    encontrada aquí, a saber, que ambos P(A) y P(B),
                                    deben ser diferentes de cero antes de que las igualdades anteriores sean
                                    significativas.

                                    <br><br> <a href="#"
                                        onclick="document.getElementById('hiddenText065').style.display='block'; return false;">SIGUIENTE</a>

                                    <div style="display: none;" id="hiddenText065">
                                        <br><br>
                                        <o>Paso 6:</o> Aplicando la fórmula de independencia de dos eventos.<br>
                                        <br><img src="media/img/paso6_ej6.png" alt=""><br>
                                        Así encontramos que, como ni P(A) ni P(B) son iguales a cero, las probabilidades
                                        no condicionales son iguales a las probabilidades
                                        condicionales si y sólo si P(A&#8745;B)=P(A)P(B).

                                        <br><br> <a href="#"
                                            onclick="document.getElementById('hiddenText066').style.display='block'; return false;">SIGUIENTE</a>

                                        <div style="display: none;" id="hiddenText066">
                                            <p><br><br><b>Resultado.</b> En estos eventos A y B definidos como "el
                                                primer dado muestra un número par" y "el segundo dado muestra
                                                un 5 o un 6" respectivamente, hemos demostrado que estos eventos son
                                                independientes. Esto se evidencia en los cálculos de las
                                                probabilidades condicionales y no condicionales, así como en la
                                                verificación de la igualdad de independencia. Además, hemos
                                                establecido que la independencia de dos eventos implica que la
                                                probabilidad de la intersección de ambos eventos es igual al
                                                producto de sus probabilidades individuales, siempre y cuando ambas
                                                probabilidades no sean cero.
                                            </p>
            </h4>
            </div>
            </div>
            </div>
            </div>
            </div>
            </div>
            </div>

            <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
            <h2>
                <v>4.4 Grafos Planos y Aplicaciones </v>
            </h2>
            <li>
                <h3>4.4.1 Ejemplo 8: Planaridad en Diseño de Circuitos Electrónicos
                </h3>
            </li>
            <h4 style="text-align: justify;">
                Un circuito electrónico se representa como un grafo donde los nodos son componentes y las aristas son
                conexiones. Determinar:  <br>
                &emsp;&emsp;a) Si el grafo es plano.<br>
                &emsp;&emsp;b) Reorganizar el diseño para evitar cruce de cables si no es plano.<br>


                <br><a href="#"
                    onclick="document.getElementById('hiddenText070').style.display='block'; return false;">SOLUCIÓN.</a>
                <div style="display: none;" id="hiddenText070">
                    <br><br>
                    <o>Paso 1:</o> Primero definimos los eventos.<br>
                    <br><img src="media/img/paso1_ej7.png" alt="">

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText071').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText071">
                        <br><br>
                        <o>Paso 2:</o> Vamos a definir el complemento para cada situación.<br>
                        <br><img src="media/img/paso2_ej7.png" alt="">

                        <br><br> <a href="#"
                            onclick="document.getElementById('hiddenText072').style.display='block'; return false;">SIGUIENTE</a>

                        <div style="display: none;" id="hiddenText072">
                            <br><br>
                            <o>Paso 3:</o> Haciendo la intersección de cada evento y aplicando la fórmula de
                            independencia. Resolvemos para cada
                            inciso: <br><br>

                            a) Ambos aprueben.
                            <img src="media/img/paso3_ej7.png" alt="">
                            <p><br><b>Resultado a)</b> La probabilidad de que ambos aprueben el curso es del 28%. Esta
                                es la multiplicación de las
                                probabilidades individuales de que Carlos y Ana aprueben.
                            </p><br>

                            b) Ninguno apruebe. <br>
                            Usaremos la propiedad del complemento:
                            <img src="media/img/paso3_ej72.png" alt=""><br>
                            Ahora aplicaremos fórmula de independencia:
                            <img src="media/img/paso3_ej73.png" alt="">
                            <p><br><b>Resultado b)</b> La probabilidad de que ninguno de ellos apruebe el curso es del
                                18%. Esto se obtiene utilizando
                                la independencia de los eventos.
                            </p><br>

                            c) Al menos uno apruebe. <br>
                            Con los cálculos del inciso anterior:
                            <img src="media/img/paso3_ej74.png" alt="">
                            <p><br><b>Resultado c)</b> La probabilidad de que al menos uno de ellos apruebe el curso es
                                del 82%. Esto se obtiene
                                utilizando la propiedad complementaria de la probabilidad.
                            </p>
            </h4>
            </div>
            </div>
            </div>

            <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>

            <li>
                <h3>4.4.2 Ejemplo 9: Rutas Cerradas y Simples en Procesos de Manufactura
                </h3>
            </li>
            <h4 style="text-align: justify;">
                Un proceso de manufactura se modela con un grafo donde cada nodo es una tarea. Identificar: <br>
                &emsp; a) Rutas cerradas para detectar tareas repetitivas.
                &emsp;b) Rutas simples para optimizar la secuencia del proceso.
                <br><br>

                <a href="#"
                    onclick="document.getElementById('hiddenText080').style.display='block'; return false;">SOLUCIÓN.</a>
                <div style="display: none;" id="hiddenText080">
                    <br><br>
                    <o>Paso 1:</o> Primero se precisa definir los eventos.<br>
                    <br><img src="media/img/paso1_ej8.png" alt="">

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText081').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText081">
                        <br><br>
                        <o>Paso 2:</o> Para ejemplificar de manera gráfica lo anterior, se sugiere desarrollar el
                        diagrama de árbol correspondiente.<br>
                        <br><img src="media/img/paso2_ej8.png" alt="">

                        <br><br> <a href="#"
                            onclick="document.getElementById('hiddenText082').style.display='block'; return false;">SIGUIENTE</a>

                        <div style="display: none;" id="hiddenText082">
                            <br><br>
                            <o>Paso 3:</o> Luego, debe considerarse que las unidades defectuosas pueden provenir de M1,
                            M2 o M3, por lo que a estas se les
                            considera eventos mutuamente exclusivos; esto es que el que una unidad haya sido producida
                            en una máquina en específico no afecta
                            el hecho de que provenga de otras máquinas. Entonces: <br>
                            <br><img src="media/img/paso3_ej8.png" alt=""><br>

                            <br><br> <a href="#"
                                onclick="document.getElementById('hiddenText083').style.display='block'; return false;">SIGUIENTE</a>

                            <div style="display: none;" id="hiddenText083">
                                <br><br>
                                <o>Paso 4:</o> Aplicando el teorema de Bayes: <br>
                                <br><img src="media/img/paso4_ej8.png" alt=""><br>

                                <p><br><b>Resultado.</b> Por lo tanto, la probabilidad de que si se selecciona una
                                    unidad al azar y es defectuosa, esta se
                                    haya empacado en la máquina 2 es de 36.42%.
                                </p>
            </h4>
            </div>
            </div>
            </div>
            </div>

            <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
            <h2>
                <v>4.5 Grafos Bipartitos y Asignación de Recursos
                </v>
            </h2>
            <li>
                <h3>4.5.1 Ejemplo 10: Asignación Óptima de Recursos con Grafos Bipartitos</h3>
            </li>

            <h4 style="text-align: justify;">
                Una empresa tiene empleados y tareas representados en un grafo bipartito. Determinar:   <br><br>
                &emsp; a) La mejor asignación de empleados a tareas.
                &emsp;b) Tareas no asignadas que pueden optimizarse.<br><br>

                <a href="#"
                    onclick="document.getElementById('hiddenText090').style.display='block'; return false;">SOLUCIÓN.</a>
                <div style="display: none;" id="hiddenText090">
                    <br><br>
                    <o>Paso 1:</o> Primero se precisa definir los eventos.<br>
                    <br><img src="media/img/paso1_ej9.png" alt="">

                    <br><br> <a href="#"
                        onclick="document.getElementById('hiddenText091').style.display='block'; return false;">SIGUIENTE</a>

                    <div style="display: none;" id="hiddenText091">
                        <br><br>
                        <o>Paso 2:</o> Para ejemplificar de manera gráfica lo anterior, se sugiere desarrollar el
                        diagrama de árbol correspondiente.<br>
                        <br><img src="media/img/paso2_ej9.png" alt="">

                        <br><br> <a href="#"
                            onclick="document.getElementById('hiddenText092').style.display='block'; return false;">SIGUIENTE</a>

                        <div style="display: none;" id="hiddenText092">
                            <br><br>
                            <o>Paso 3:</o> Luego, debe considerarse que las bolas blancas pueden provenir de U1, U2 o
                            U3, por lo que a estas se
                            les considera eventos mutuamente exclusivos. Entonces: <br>
                            <br><img src="media/img/paso3_ej9.png" alt=""><br>

                            <br><br> <a href="#"
                                onclick="document.getElementById('hiddenText093').style.display='block'; return false;">SIGUIENTE</a>

                            <div style="display: none;" id="hiddenText093">
                                <br><br>
                                <o>Paso 4:</o> Aplicando el teorema de Bayes: <br>
                                <br><img src="media/img/paso4_ej9.png" alt=""><br>

                                <p><br><b>Resultado.</b> Por lo tanto, la probabilidad de que la bola blanca se haya
                                    elegido de la urna 1 es de 33.33%.
                                    Y, de que se haya elegido de la urna 3 es de 44.44%.
                                </p>
            </h4>
            </div>
            </div>
            </div>
            </div>


            </div>
            </div>
            </div>
            </div>
            <p>━━━━━━━━━━━━━━━━━━━ ◦ ❖ ◦ ━━━━━━━━━━━━━━━━━</p>
            </ul>
            </div>
    </section>
</section>

</html>